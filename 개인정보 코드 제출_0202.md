1\.  
\[개인정보 조회 로그 기록/3년 경과 삭제 관련 코드 발췌\]

1\) 관리자(sysop) \- 로그 객체 준비  
파일: public\_html/sysop/init.jsp  
\------------------------------------------------------------  
InfoLogDao \_log \= new InfoLogDao(siteId); \_log.setItems(userId, "B", surl, userIp);  
\------------------------------------------------------------

2\) 관리자(sysop) \- 개인정보 조회 로그 기록 예시(회원 상세)  
파일: public\_html/sysop/crm/user\_view.jsp  
\------------------------------------------------------------  
//기록-개인정보조회  
if(\!isBlindUser) \_log.add("V", "회원정보 상세조회", 1, "이러닝 운영", info);  
\------------------------------------------------------------

3\) 교수자/관리자(tutor\_lms) \- 개인정보 조회/다운로드 사유 로그 기록 API  
파일: public\_html/tutor\_lms/api/privacy\_log.jsp  
\------------------------------------------------------------  
InfoLogDao infoLog \= new InfoLogDao(siteId);  
String pagePath \= request.getRequestURI() \+ (\!"".equals(m.qs()) ? "?" \+ m.qs() : "");  
infoLog.setItems(userId, "T", pagePath, userIp);

int logId \= infoLog.add(logType, pageNm, userCnt, purpose, list);  
\------------------------------------------------------------

4\) 개인정보 조회 로그 3년 경과 시 자동 삭제(조회 시점 실행 \+ 사이트별 하루 1회)  
파일: src/dao/InfoLogDao.java  
\------------------------------------------------------------  
import java.util.concurrent.ConcurrentHashMap;

private static final ConcurrentHashMap\<Integer, String\> LAST\_PURGE\_DATE\_BY\_SITE \= new ConcurrentHashMap\<\>();

public int add(String logType, String pageNm, int userCnt, String purpose, DataSet list) {  
    if(this.userId \== 0 || "".equals(this.pagePath) || "".equals(this.ipAddr)) return 0;

    // 왜: 개인정보 조회 로그를 3년까지만 보관해야 하므로, 조회 시점에 오래된 로그를 정리합니다.  
    this.purgeExpiredLogs();

    String now \= Malgn.time("yyyyMMddHHmmss");  
    String today \= Malgn.time("yyyyMMdd");  
    String stdate \= Malgn.addDate("I", \-exclusion, now, "yyyyMMddHHmmss");  
    InfoUserDao \_logUser \= new InfoUserDao(siteId); \_logUser.setInsertIgnore(true);

    if(0 \< this.findCount(  
            "log\_cate \= '" \+ this.logCate \+ "' AND log\_type \= '" \+ logType \+ "' "  
                    \+ " AND page\_path \= '" \+ this.pagePath \+ "' AND manager\_id \= " \+ this.userId \+ " "  
                    \+ " AND ip\_addr \= '" \+ this.ipAddr \+ "' "  
                    \+ " AND site\_id \= " \+ this.siteId  
                    \+ " AND reg\_date \>= '" \+ stdate \+ "' "  
    )) return \-1;

    int newId \= this.getSequence();

    this.item("id", newId);  
    this.item("log\_date", today);  
    this.item("log\_cate", this.logCate);  
    this.item("log\_type", logType);  
    this.item("page\_nm", pageNm);  
    this.item("page\_path", this.pagePath);  
    this.item("user\_cnt", userCnt);  
    this.item("purpose", purpose);  
    this.item("memo", "");  
    this.item("manager\_id", this.userId);  
    this.item("ip\_addr", this.ipAddr);  
    this.item("site\_id", siteId);  
    this.item("reg\_date", now);  
    this.item("status", 1);

    this.insert();  
    if(newId \> 0 && list \!= null) \_logUser.add(newId, list);

    return newId;  
}

public void purgeExpiredLogs() {  
    if(this.siteId \== 0\) return;

    String today \= Malgn.time("yyyyMMdd");  
    String lastPurgeDate \= LAST\_PURGE\_DATE\_BY\_SITE.get(this.siteId);  
    if(today.equals(lastPurgeDate)) return;

    // 왜: 하루 1회만 정리하여 불필요한 반복 삭제를 막습니다.  
    LAST\_PURGE\_DATE\_BY\_SITE.put(this.siteId, today);

    String now \= Malgn.time("yyyyMMddHHmmss");  
    String cutoff \= Malgn.addDate("M", \-36, now, "yyyyMMddHHmmss");

    // 왜: 연결 테이블을 먼저 지워야 로그 삭제 후에도 고아 데이터가 남지 않습니다.  
    this.execute(  
        "DELETE FROM TB\_INFO\_USER "  
        \+ " WHERE site\_id \= " \+ this.siteId  
        \+ " AND log\_id IN ("  
        \+ " SELECT id FROM " \+ this.table  
        \+ " WHERE site\_id \= " \+ this.siteId  
        \+ " AND reg\_date \< '" \+ cutoff \+ "'"  
        \+ " )"  
    );

    // 왜: 3년이 지난 개인정보 조회 로그를 정리하여 보관 기간을 지킵니다.  
    this.execute(  
        "DELETE FROM " \+ this.table  
        \+ " WHERE site\_id \= " \+ this.siteId  
        \+ " AND reg\_date \< '" \+ cutoff \+ "'"  
    );  
}  
\------------------------------------------------------------

2\.

SSO 로그인 시 최초 1회 동의 체크

if("Y".equals(siteinfo.s("sso\_privacy\_yn")) && \!"Y".equals(info.s("privacy\_yn"))) {  
    String pek \= m.encrypt("PRIVACY\_" \+ info.s("id") \+ "\_AGREE\_" \+ m.time("yyyyMMdd"));  
    m.redirect("privacy\_agree.jsp?id=" \+ info.s("id") \+ "\&ek=" \+ pek \+ ...); return;  
}

동의 처리 및 “동의 시점 로그(TB\_AGREEMENT\_LOG.reg\_date)” 저장  
agreementLog.insertLog(siteinfo, info, "privacy", "Y", "privacy\_agree");

3\.

유저 접속 기록 2년 보관 후 자동 파기

package dao;

import java.util.concurrent.ConcurrentHashMap;  
import malgnsoft.db.\*;  
import malgnsoft.util.\*;

public class UserLoginDao extends DataObject {

	public String\[\] adminYnList \= { "N=\>사용자단", "Y=\>관리자단" };  
	public String\[\] loginTypeList \= { "I=\>로그인", "O=\>로그아웃", "S=\>세션만료" };  
	  
	public String\[\] adminYnListMsg \= { "N=\>list.user\_login.admin\_yn\_list.N", "Y=\>list.user\_login.admin\_yn\_list.Y" };  
	public String\[\] loginTypeListMsg \= { "I=\>list.user\_login.login\_type\_list.I", "O=\>list.user\_login.login\_type\_list.O", "S=\>list.user\_login.login\_type\_list.S" };

	private static final ConcurrentHashMap\<Integer, String\> LAST\_PURGE\_DATE\_BY\_SITE \= new ConcurrentHashMap\<\>();  
	  
	public UserLoginDao() {  
		this.table \= "TB\_USER\_LOGIN";  
	}

	public void purgeExpiredLogs(int siteId) {  
		if(siteId \== 0\) return;

		String today \= Malgn.time("yyyyMMdd");  
		String lastPurgeDate \= LAST\_PURGE\_DATE\_BY\_SITE.get(siteId);  
		if(today.equals(lastPurgeDate)) return;

		// 왜: 하루 1회만 정리하여 불필요한 반복 삭제를 막습니다.  
		LAST\_PURGE\_DATE\_BY\_SITE.put(siteId, today);

		String now \= Malgn.time("yyyyMMddHHmmss");  
		String cutoff \= Malgn.addDate("Y", \-2, now, "yyyyMMddHHmmss");

		// 왜: 접속 로그는 2년만 보관해야 하므로 오래된 로그를 정리합니다.  
		this.execute(  
			"DELETE FROM " \+ this.table  
			\+ " WHERE site\_id \= " \+ siteId  
			\+ " AND reg\_date \< '" \+ cutoff \+ "'"  
		);  
	}

	public boolean isMobile(String agent) {  
		boolean isMobile \= false;  
		if(null \!= agent) {  
			String\[\] mobileKeyWords \= {  
				"iPhone", "iPod", "iPad"  
				, "BlackBerry", "Android", "Windows CE"  
				, "LG", "MOT", "SAMSUNG", "SonyEricsson"  
			};  
			for(int i=0; i\<mobileKeyWords.length; i++) {  
				if(agent.indexOf(mobileKeyWords\[i\]) \!= \-1) {  
					isMobile \= true;  
					break;  
				}  
			}  
		}  
		return isMobile;  
	}

	public String getDeviceType(String agent) {  
		if(this.isMobile(agent)) return "Mobile";  
		else return "PC";  
	}  
}

호출 위치 (SSO 로그인 한 곳만)

//로그  
// 왜: 접속 로그는 2년만 보관해야 하므로, 저장 전에 오래된 로그를 정리합니다.  
userLogin.purgeExpiredLogs(siteId);  
userLogin.item("id", userLogin.getSequence());  
userLogin.item("site\_id", siteId);  
userLogin.item("user\_id", info.i("id"));  
userLogin.item("admin\_yn", "N");  
userLogin.item("login\_type", "I");  
userLogin.item("ip\_addr", userIp);  
userLogin.item("agent", request.getHeader("user-agent"));  
userLogin.item("device", userLogin.getDeviceType(request.getHeader("user-agent")));  
userLogin.item("log\_date", m.time("yyyyMMdd"));  
userLogin.item("reg\_date", m.time("yyyyMMddHHmmss"));  
if(\!userLogin.insert()) { }

4\.  
학사정보 동기화하여 유저 삭제되는 로직

// 왜: 학사에서 삭제된 사용자를 LMS 회원에서도 자동 처리(논리삭제)하려면,  
//     “old에는 있고 new에는 없는” member\_key를 기준으로 TB\_USER를 찾습니다.  
if(enableUserAutoDelete) {  
	UserDao userDao \= new UserDao();  
	try {  
		String joinCond \= "u.etc3 \= o.member\_key";  
		if(matchLoginIdAlso) joinCond \= "(" \+ joinCond \+ " OR u.login\_id \= o.member\_key)";

		DataSet delUsers \= userDao.query(  
			" SELECT DISTINCT u.id, u.login\_id "  
			\+ " FROM TB\_USER u "  
			\+ " INNER JOIN " \+ polyMemberTmp.table \+ " o ON " \+ joinCond  
			\+ " LEFT JOIN " \+ polyMember.table \+ " n ON n.member\_key \= o.member\_key "  
			\+ " WHERE u.site\_id \= " \+ siteId  
			\+ " AND u.status \!= \-1 AND u.user\_kind \= 'U' "  
			\+ " AND n.member\_key IS NULL "  
		);

		userDeleteCandidate \= delUsers.size();  
		delUsers.first();  
		while(delUsers.next()) {  
			String lid \= delUsers.s("login\_id");  
			if(lid \== null) lid \= "";  
			lid \= lid.trim();

			// 왜: 테스트 계정/관리자자 계정은 운영 정책상 자동삭제 대상에서 제외해야 합니다.  
			if(excludeLoginIds.contains(lid)) { userDeleteSkipped++; continue; }

			if(dryRunUserDelete) { continue; }

			boolean ok \= userDao.deleteUser(delUsers.i("id"));  
			if(ok) userDeleteDone++;  
			else userDeleteFailed++;  
		}  
		delUsers.first();  
	} catch(Exception e) {  
		syncLog.upsert(syncKey, "ERR", "TB\_USER 자동삭제 처리 실패: " \+ e.getMessage());  
		throw e;  
	}  
}

실제 삭제 처리 함수  
public boolean deleteUser(int userId) {  
	if(0 \== userId) return false;  
	DataSet uinfo \= this.find("id \= " \+ userId \+ " AND status \!= \-1");  
	if(\!uinfo.next()) return false;

	this.item("user\_nm", "\[탈퇴\]");  
	this.item("email", "");  
	this.item("mobile", "");  
	this.item("passwd", "");  
	this.item("access\_token", "");  
	this.item("gender", "");  
	this.item("birthday", "");  
	this.item("zipcode", "");  
	this.item("addr", "");  
	this.item("new\_addr", "");  
	this.item("addr\_dtl", "");  
	this.item("etc1", "");  
	this.item("etc2", "");  
	this.item("etc3", "");  
	this.item("etc4", "");  
	this.item("etc5", "");  
	this.item("dupinfo", "");  
	this.item("oauth\_vendor", "");  
	this.item("status", \-1);  
	return this.update("id \= " \+ userId);  
}

